/******************************************************************************
 * This file was generated by langium-visitor.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

import * as ASTInterfaces from '../language/generated/ast.js';
import { LangiumCoreServices, Reference, ValidationAcceptor, ValidationChecks } from 'langium';

/**
 * This interface is used to define the visitor methods for the RoboMl language.
 */
export interface RoboMlVisitor {
    visitExpression(node : Expression) : any;
    visitBinaryExpression(node : BinaryExpression) : any;
    visitBooleanLiteral(node : BooleanLiteral) : any;
    visitFunctionCall(node : FunctionCall) : any;
    visitNumberLiteral(node : NumberLiteral) : any;
    visitSensorAccess(node : SensorAccess) : any;
    visitVariableRef(node : VariableRef) : any;
    visitFunctionDef(node : FunctionDef) : any;
    visitInstruction(node : Instruction) : any;
    visitAssignment(node : Assignment) : any;
    visitCondition(node : Condition) : any;
    visitLoop(node : Loop) : any;
    visitMovement(node : Movement) : any;
    visitReturn(node : Return) : any;
    visitRotate(node : Rotate) : any;
    visitSetSpeed(node : SetSpeed) : any;
    visitVariableDeclaration(node : VariableDeclaration) : any;
    visitProgram(node : Program) : any;
    visitVariable(node : Variable) : any;
}

/**
 * This abstract class is used to implement a validation visitor for the RoboMl language.
 * It uses the Langium validator service under the hood and exposes its `accept` method through the `validationAccept` property.
 * This `validationAccept` property is reassigned each time the `visitRoot` method is called, so when Langium called the different validation checks.
 */
export abstract class RoboMlValidationVisitor {

    protected validationAccept: ValidationAcceptor = () => {};

    visitRoot(node: Program, accept: ValidationAcceptor) {
        this.validationAccept = accept;
        node.accept(this);
    }
    
    abstract visitExpression(node : Expression) : any;
    abstract visitBinaryExpression(node : BinaryExpression) : any;
    abstract visitBooleanLiteral(node : BooleanLiteral) : any;
    abstract visitFunctionCall(node : FunctionCall) : any;
    abstract visitNumberLiteral(node : NumberLiteral) : any;
    abstract visitSensorAccess(node : SensorAccess) : any;
    abstract visitVariableRef(node : VariableRef) : any;
    abstract visitFunctionDef(node : FunctionDef) : any;
    abstract visitInstruction(node : Instruction) : any;
    abstract visitAssignment(node : Assignment) : any;
    abstract visitCondition(node : Condition) : any;
    abstract visitLoop(node : Loop) : any;
    abstract visitMovement(node : Movement) : any;
    abstract visitReturn(node : Return) : any;
    abstract visitRotate(node : Rotate) : any;
    abstract visitSetSpeed(node : SetSpeed) : any;
    abstract visitVariableDeclaration(node : VariableDeclaration) : any;
    abstract visitProgram(node : Program) : any;
    abstract visitVariable(node : Variable) : any;
}


/**
 * This function is used to register a validation visitor for the RoboMl language.
 * It will register the `visitRoot` method as a validation check for the Program type.
 * @param visitor - The visitor to register.
 * @param services - The Langium services.
 */
export function registerVisitorAsValidator<T extends RoboMlValidationVisitor>(visitor: T, services: LangiumCoreServices) {
    const registry = services.validation.ValidationRegistry;
    const checks: ValidationChecks<ASTInterfaces.RoboMlAstType> = {
        Program: (node, accept) => {
            visitor.visitRoot(node as Program, accept);
        }
    };
    registry.register(checks, visitor);
}


/* Each concrete interfaces in the `ast.js` file have an equivalent generated type with the same properties but also with an `accept` method.
 * While the generated accept-weaver allows us to dynamically add the `accept` function to Langium's types, these types allow it to exist statically, so we can take advantage of TypeScript's typing.
 * The references are overrided to use the visitor types instead of the Langium interfaces/types.
 * Nevertheless, the two are strictly equivalent, and conversion from one to the other is made possible thanks to duck-typing.
 */

type Acceptor = {
    accept: (visitor: RoboMlVisitor) => any;
}

function isAcceptor(node: unknown): node is Acceptor {
    return typeof (node as any).accept === 'function';
}


export type Expression = Acceptor & ASTInterfaces.Expression

export function isExpression(node: unknown): node is Expression {
    return ASTInterfaces.isExpression(node) && isAcceptor(node);
}


export type BinaryExpression = Acceptor & Omit<ASTInterfaces.BinaryExpression, 'left' | 'operator' | 'right'> & {
    left: Expression;
    operator: Operator;
    right: Expression;
}

export function isBinaryExpression(node: unknown): node is BinaryExpression {
    return ASTInterfaces.isBinaryExpression(node) && isAcceptor(node);
}


export type BooleanLiteral = Acceptor & ASTInterfaces.BooleanLiteral

export function isBooleanLiteral(node: unknown): node is BooleanLiteral {
    return ASTInterfaces.isBooleanLiteral(node) && isAcceptor(node);
}


export type FunctionCall = Acceptor & Omit<ASTInterfaces.FunctionCall, 'function' | 'arguments'> & {
    function: Reference<FunctionDef>;
    arguments: Array<Expression>;
}

export function isFunctionCall(node: unknown): node is FunctionCall {
    return ASTInterfaces.isFunctionCall(node) && isAcceptor(node);
}


export type NumberLiteral = Acceptor & ASTInterfaces.NumberLiteral

export function isNumberLiteral(node: unknown): node is NumberLiteral {
    return ASTInterfaces.isNumberLiteral(node) && isAcceptor(node);
}


export type SensorAccess = Acceptor & Omit<ASTInterfaces.SensorAccess, 'sensor'> & {
    sensor: SensorType;
}

export function isSensorAccess(node: unknown): node is SensorAccess {
    return ASTInterfaces.isSensorAccess(node) && isAcceptor(node);
}


export type VariableRef = Acceptor & Omit<ASTInterfaces.VariableRef, 'variable'> & {
    variable: Reference<Variable>;
}

export function isVariableRef(node: unknown): node is VariableRef {
    return ASTInterfaces.isVariableRef(node) && isAcceptor(node);
}


export type FunctionDef = Acceptor & Omit<ASTInterfaces.FunctionDef, '$container' | 'parameters' | 'returnType' | 'instructions'> & {
    $container: Program;
    parameters: Array<Variable>;
    returnType: RType;
    instructions: Array<Instruction>;
}

export function isFunctionDef(node: unknown): node is FunctionDef {
    return ASTInterfaces.isFunctionDef(node) && isAcceptor(node);
}


export type Instruction = Acceptor & ASTInterfaces.Instruction

export function isInstruction(node: unknown): node is Instruction {
    return ASTInterfaces.isInstruction(node) && isAcceptor(node);
}


export type Assignment = Acceptor & Omit<ASTInterfaces.Assignment, 'assignee' | 'value'> & {
    assignee: Reference<Variable>;
    value: Expression;
}

export function isAssignment(node: unknown): node is Assignment {
    return ASTInterfaces.isAssignment(node) && isAcceptor(node);
}


export type Condition = Acceptor & Omit<ASTInterfaces.Condition, 'condition' | 'thenBody' | 'elseBody'> & {
    condition: Expression;
    thenBody: Array<Instruction>;
    elseBody: Array<Instruction>;
}

export function isCondition(node: unknown): node is Condition {
    return ASTInterfaces.isCondition(node) && isAcceptor(node);
}


export type Loop = Acceptor & Omit<ASTInterfaces.Loop, 'condition' | 'body'> & {
    condition: Expression;
    body: Array<Instruction>;
}

export function isLoop(node: unknown): node is Loop {
    return ASTInterfaces.isLoop(node) && isAcceptor(node);
}


export type Movement = Acceptor & Omit<ASTInterfaces.Movement, 'direction' | 'distance' | 'unit'> & {
    direction: MoveDirection;
    distance: Expression;
    unit: Unit;
}

export function isMovement(node: unknown): node is Movement {
    return ASTInterfaces.isMovement(node) && isAcceptor(node);
}


export type Return = Acceptor & Omit<ASTInterfaces.Return, 'value'> & {
    value: Expression;
}

export function isReturn(node: unknown): node is Return {
    return ASTInterfaces.isReturn(node) && isAcceptor(node);
}


export type Rotate = Acceptor & Omit<ASTInterfaces.Rotate, 'direction' | 'angle'> & {
    direction: RotateDirection;
    angle: Expression;
}

export function isRotate(node: unknown): node is Rotate {
    return ASTInterfaces.isRotate(node) && isAcceptor(node);
}


export type SetSpeed = Acceptor & Omit<ASTInterfaces.SetSpeed, 'unit' | 'value'> & {
    unit: Unit;
    value: Expression;
}

export function isSetSpeed(node: unknown): node is SetSpeed {
    return ASTInterfaces.isSetSpeed(node) && isAcceptor(node);
}


export type VariableDeclaration = Acceptor & Omit<ASTInterfaces.VariableDeclaration, 'variable' | 'value' | 'unit'> & {
    variable: Variable;
    value: Expression;
    unit: Unit;
}

export function isVariableDeclaration(node: unknown): node is VariableDeclaration {
    return ASTInterfaces.isVariableDeclaration(node) && isAcceptor(node);
}


export type Program = Acceptor & Omit<ASTInterfaces.Program, 'functions'> & {
    functions: Array<FunctionDef>;
}

export function isProgram(node: unknown): node is Program {
    return ASTInterfaces.isProgram(node) && isAcceptor(node);
}


export type Variable = Acceptor & Omit<ASTInterfaces.Variable, '$container' | 'type'> & {
    $container: FunctionDef | VariableDeclaration;
    type: RType;
}

export function isVariable(node: unknown): node is Variable {
    return ASTInterfaces.isVariable(node) && isAcceptor(node);
}


/*
 * Each union type in the `ast.js` file have an equivalent generated type but using the visitor classes instead of the Langium interfaces/types.
 * This type is used to propose the `accept` method of their generated types.
 */

export type MoveDirection = 'Forward' | 'Backward' | 'Left' | 'Right';

export type Operator = '+' | '-' | '*' | '/' | '<' | '>' | '==';

export type RotateDirection = 'Clock' | 'Counter';

export type RType = 'number' | 'boolean' | 'void';

export type SensorType = 'getDistance' | 'getTimestamp';

export type Unit = 'cm' | 'mm';
