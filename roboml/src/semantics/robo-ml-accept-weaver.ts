/******************************************************************************
 * This file was generated by langium-visitor.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

import { AstNode, AstUtils, ContextCache, DocumentState, LangiumCoreServices } from 'langium';
import type { RoboMlAstType } from '../language/generated/ast.js';
import * as InterfaceAST from '../language/generated/ast.js';
import * as ClassAST from './robo-ml-visitor.js';
import { RoboMlVisitor } from './robo-ml-visitor.js';
import { DiagnosticSeverity } from 'vscode-languageserver';


type Weaver = {
    [K in keyof RoboMlAstType]?: (node: RoboMlAstType[K]) => void;
}

/**
 * This class is used to dynamically add an `accept` method to the Langium generated (concrete) types.
 * It is executed when each time a Langium document goes in "IndexedReferences" state, before the validation phase, but use a cache to avoid reweaving the same AST nodes multiple times.
 */
export class RoboMlAcceptWeaver {
    
    private readonly checks: Weaver = {
        BinaryExpression: this.weaveBinaryExpression,
        BooleanLiteral: this.weaveBooleanLiteral,
        FunctionCall: this.weaveFunctionCall,
        NumberLiteral: this.weaveNumberLiteral,
        SensorAccess: this.weaveSensorAccess,
        VariableRef: this.weaveVariableRef,
        FunctionDef: this.weaveFunctionDef,
        Assignment: this.weaveAssignment,
        Condition: this.weaveCondition,
        Loop: this.weaveLoop,
        Movement: this.weaveMovement,
        Return: this.weaveReturn,
        Rotate: this.weaveRotate,
        SetSpeed: this.weaveSetSpeed,
        VariableDeclaration: this.weaveVariableDeclaration,
        Program: this.weaveProgram,
        Variable: this.weaveVariable
    };

    private readonly cache: ContextCache<AstNode, string, void>;

    constructor(services: LangiumCoreServices) {
        this.cache = new ContextCache<AstNode, string, void>();
        services.shared.workspace.DocumentBuilder.onDocumentPhase(DocumentState.IndexedReferences, (document) => {
            if(!document.diagnostics || document.diagnostics.filter(d => d.severity === DiagnosticSeverity.Error).length === 0) {
                AstUtils.streamAst(document.parseResult.value).forEach((node: AstNode) => {
                    if(!this.cache.has(node, 'weaved')) {
                        const nodeType = node.$type as keyof Weaver;
                        const weaveFunction = this.checks[nodeType]; 
                        if (weaveFunction) {
                            weaveFunction(node as any);
                            this.cache.set(node, 'weaved', undefined);
                        }
                    }
                });
            }
        });
    }

    
    weaveBinaryExpression(node : InterfaceAST.BinaryExpression) : void {
        (<any> node).accept = (visitor: RoboMlVisitor) => { return visitor.visitBinaryExpression(node as unknown as ClassAST.BinaryExpression); }
    }
    
    weaveBooleanLiteral(node : InterfaceAST.BooleanLiteral) : void {
        (<any> node).accept = (visitor: RoboMlVisitor) => { return visitor.visitBooleanLiteral(node as unknown as ClassAST.BooleanLiteral); }
    }
    
    weaveFunctionCall(node : InterfaceAST.FunctionCall) : void {
        (<any> node).accept = (visitor: RoboMlVisitor) => { return visitor.visitFunctionCall(node as unknown as ClassAST.FunctionCall); }
    }
    
    weaveNumberLiteral(node : InterfaceAST.NumberLiteral) : void {
        (<any> node).accept = (visitor: RoboMlVisitor) => { return visitor.visitNumberLiteral(node as unknown as ClassAST.NumberLiteral); }
    }
    
    weaveSensorAccess(node : InterfaceAST.SensorAccess) : void {
        (<any> node).accept = (visitor: RoboMlVisitor) => { return visitor.visitSensorAccess(node as unknown as ClassAST.SensorAccess); }
    }
    
    weaveVariableRef(node : InterfaceAST.VariableRef) : void {
        (<any> node).accept = (visitor: RoboMlVisitor) => { return visitor.visitVariableRef(node as unknown as ClassAST.VariableRef); }
    }
    
    weaveFunctionDef(node : InterfaceAST.FunctionDef) : void {
        (<any> node).accept = (visitor: RoboMlVisitor) => { return visitor.visitFunctionDef(node as unknown as ClassAST.FunctionDef); }
    }
    
    weaveAssignment(node : InterfaceAST.Assignment) : void {
        (<any> node).accept = (visitor: RoboMlVisitor) => { return visitor.visitAssignment(node as unknown as ClassAST.Assignment); }
    }
    
    weaveCondition(node : InterfaceAST.Condition) : void {
        (<any> node).accept = (visitor: RoboMlVisitor) => { return visitor.visitCondition(node as unknown as ClassAST.Condition); }
    }
    
    weaveLoop(node : InterfaceAST.Loop) : void {
        (<any> node).accept = (visitor: RoboMlVisitor) => { return visitor.visitLoop(node as unknown as ClassAST.Loop); }
    }
    
    weaveMovement(node : InterfaceAST.Movement) : void {
        (<any> node).accept = (visitor: RoboMlVisitor) => { return visitor.visitMovement(node as unknown as ClassAST.Movement); }
    }
    
    weaveReturn(node : InterfaceAST.Return) : void {
        (<any> node).accept = (visitor: RoboMlVisitor) => { return visitor.visitReturn(node as unknown as ClassAST.Return); }
    }
    
    weaveRotate(node : InterfaceAST.Rotate) : void {
        (<any> node).accept = (visitor: RoboMlVisitor) => { return visitor.visitRotate(node as unknown as ClassAST.Rotate); }
    }
    
    weaveSetSpeed(node : InterfaceAST.SetSpeed) : void {
        (<any> node).accept = (visitor: RoboMlVisitor) => { return visitor.visitSetSpeed(node as unknown as ClassAST.SetSpeed); }
    }
    
    weaveVariableDeclaration(node : InterfaceAST.VariableDeclaration) : void {
        (<any> node).accept = (visitor: RoboMlVisitor) => { return visitor.visitVariableDeclaration(node as unknown as ClassAST.VariableDeclaration); }
    }
    
    weaveProgram(node : InterfaceAST.Program) : void {
        (<any> node).accept = (visitor: RoboMlVisitor) => { return visitor.visitProgram(node as unknown as ClassAST.Program); }
    }
    
    weaveVariable(node : InterfaceAST.Variable) : void {
        (<any> node).accept = (visitor: RoboMlVisitor) => { return visitor.visitVariable(node as unknown as ClassAST.Variable); }
    }
    
}